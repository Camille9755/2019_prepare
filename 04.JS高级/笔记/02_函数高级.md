## 原型与原型链
* 函数的prototype属性(图)
  * 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
  * 原型对象中有一个属性constructor, 它指向函数对象
* 给原型对象添加属性(一般都是方法)
  * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)
* 所有函数都有一个特别的属性:
  * `prototype` : 显式原型属性
* 所有实例对象都有一个特别的属性:
  * `__proto__` : 隐式原型属性
* 显式原型与隐式原型的关系
  * 函数的`prototype`: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象
  * 实例对象的`__proto__`: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值
  * 实例对象的隐式原型的值为其对应构造函数的显式原型的值
  * 原型对象即为当前实例对象的父对象
  * 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)
* 原型链 
    * 别名: 隐式原型链
    * 作用: 查找对象的属性(方法) 
  * 所有的实例对象都有`__proto__`属性, 它指向的就是原型对象，
       这样通过`__proto__`属性就形成了一个链的结构---->原型链,当查找对象内部的属性/方法时, 
    js引擎自动沿着这个原型链查找
  * 访问一个对象的属性时，
     * 先在自身属性中查找，找到返回
     * 如果没有, 再沿着__proto__这条链向上查找, 找到返回
     * 如果最终没找到, 返回undefined
  * 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作  
* 原型链的属性问题
     * 读取对象的属性值时: 会自动到原型链中查找
     * 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值
     * 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上  
* instanceof是如何判断的?
  * 表达式: A instanceof B
  * 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false
* Function是通过new自己产生的实例
### 注意
1. 函数的显式原型指向的对象默认是空Object实例对象(但Object不满足)  
  `console.log(Fn.prototype instanceof Object) // true`      
  `console.log(Object.prototype instanceof Object) // false`      
  `console.log(Function.prototype instanceof Object) // true ` 
2. 所有函数都是Function的实例(包含Function)  
 ` console.log(Function.__proto__===Function.prototype)`
3. Object的原型对象是原型链尽头  
  `console.log(Object.prototype.__proto__) // null`     
  
###有两道关于原型与原型链的面试题看一下

## 执行上下文与执行上下文栈
* 栈: 后进先出
* 变量提升与函数提升
  * 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)
  * 函数提升: 在函数定义语句之前, 就执行该函数
  * 先有变量提升, 再有函数提升
* 理解
  * 执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性
  * 执行上下文栈: 用来管理产生的多个执行上下文
* 分类:
  * 全局: window
  * 函数: 对程序员来说是透明的
* 生命周期
  * 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡
  * 函数 : 调用函数时产生, 函数执行完时死亡
* 包含哪些属性:
  * 全局 : 
     * 用var定义的全局变量  ==>undefined
     * 使用function声明的函数   ===>function
     * this   ===>window
  * 函数
     * 用var定义的局部变量  ==>undefined
     * 使用function声明的函数   ===>function
     * this   ===> 调用函数的对象, 如果没有指定就是window 
     * 形参变量   ===>对应实参值
     * arguments ===>实参列表的伪数组
* 执行上下文创建和初始化的过程
  * 全局:   
      1. 在执行全局代码前将window确定为全局执行上下文
      2. 对全局数据进行预处理
         * var定义的全局变量==>undefined, 添加为window的属性
         * function声明的全局函数==>赋值(fun), 添加为window的方法
         * this==>赋值(window)
      3. 开始执行全局代码
  * 函数:
     1. 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)
     2. 对局部数据进行预处理
            * 形参变量==>赋值(实参)==>添加为执行上下文的属性
            * arguments==>赋值(实参列表), 添加为执行上下文的属性
            * var定义的局部变量==>undefined, 添加为执行上下文的属性
            * function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
            * this==>赋值(调用函数的对象)
     3. 开始执行函数体代码
###有两道关于执行上下文与执行上下文栈的面试题看一下

## 作用域与作用域链
* 理解:
  * 作用域: 一块代码区域, 在编码时就确定了, 不会再变化
  * 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量
* 分类:
  * 全局
  * 函数
  * js没有块作用域(在ES6之前)
* 作用
  * 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突
  * 作用域链: 查找变量
* 区别作用域与执行上下文
  * 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了
  * 执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失
  * 联系: 执行上下文环境是在对应的作用域中的

## 闭包 
* 理解:
  * 当嵌套的内部函数引用了外部函数的变量(函数)时就产生了闭包
  * 通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性
* 作用:
  * 延长局部变量的生命周期
  * 让函数外部能操作内部的局部变量
* 写一个闭包程序
  ```
  function fn1() {
    var a = 2;
    function fn2() {
      a++;
      console.log(a);
    }
    return fn2;
  }
  var f = fn1();
  f();
  f();
  ```
* 常见的闭包
 * 将函数作为另一个函数的返回值
 * 将函数作为实参传递给另一个函数调用
* 闭包的生命周期
 * 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)
 * 死亡: 在嵌套的内部函数成为垃圾对象时
* 闭包应用:
  * 模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为
  * 循环遍历加监听
  * JS框架(jQuery)大量使用了闭包
> JS模块   
> 1. 具有特定功能的js文件   
> 2.将所有的数据和功能都封装在一个函数内部(私有的)  
> 3.只向外暴露一个包含n个方法的对象或函数     
> 4.模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能   

* 闭包缺点:
  * 变量占用内存的时间可能会过长
  * 可能导致内存泄露
  * 解决:及时释放   --->   `f = null; //让内部函数对象成为垃圾对象`
    
## 内存溢出与内存泄露
1. 内存溢出
  * 一种程序运行出现的错误
  * 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误
2. 内存泄露
  * 占用的内存没有及时释放
  * 内存泄露积累多了就容易导致内存溢出
  * 常见的内存泄露:
    * 意外的全局变量
    * 没有及时清理的计时器或回调函数
    * 闭包
    